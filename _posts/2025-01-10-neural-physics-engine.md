---
layout: post
title: Simulating games with neural networks
date: 2025-01-10
description: Replacing game logic by a neural network
categories: building log
thumbnail: assets/img/IRIS_diagram.png
---

I recently found out about [Oasis](https://oasisaiminecraft.com/), an AI-generated Minecraft clone. You can actually play it right now from your browser, and I encourage you to do it! What you will see is entirely AI-generated: you select a world (which is just a screenshot of a scene) and then the following frames are entirely generated by a neural network.

Roughly, my guess is they gathered lots of gameplay data and trained a model to predict the next frame given the current frame and user input. Once the model is trained, it can be used as some sort of "game engine" by just feeding a screenshot of the game. Then, the neural network will start generating the next frames conditioned on our input. 

I find this idea fascinating: we are replacing all the game/code logic by a neural network that has been only trained on image data.

> The idea of this blog post is to log my adventure into learning and (hopefully) building a similar AI-generated game engine. As an experiment, I wanted to make this public since the start so that I commit to it. However, expect this to be a little bit messy at first!

## World Models

If we want to build a similar AI-generated game, the first thing to do is to look into the literature. I found out that Oasis is powered by a world model [1], whose task is to predict the next state of the world given the previous state/s and action/s. You can find quite a lot of papers related to world models, as well as technical info about Oasis [2].

However, I think that it is important to not overcomplicate things when building something for the first time. In this specific case, it implies (i) avoiding models/techniques that require a huge amount of computing (e.g. training a ViT on lots of Minecraft gameplay) and (ii) avoiding super complicated techniques that provide marginal increases in performance. In other words, adding a complicated training scheme to improve performance by 2% may be essential when building an actual product, but if we want to learn, we should get away with the simplest solution.

I think that IRIS [3] is a good candidate, as it is relatively simple, it works on small Atari games requiring small amounts of data and I think that it is also being used in production at comma.ai. 

Also note that most of the papers that talk about world models are related to Reinforcement Learning (RL). The main idea of all those papers is that RL agents are extremely sample inefficient, so it might be a good idea to learn a world model of the environment that can then be used to train the RL agent in its own "imagination". Most papers follow a scheme of (i) gathering observations from the environment (ii) training the world model (iii) training the RL agent with the world model. In our case, we are only interested in the second step, while the RL agent is just used to gather data from the environment (instead of us having to play for hours to gather data). In other words, we actually don't care that the RL agent performs well, we just want to have a decent world model.

## IRIS

Let's look at the diagram below. We have the following components:

- A **discrete autoencoder** composed by the encoder $$E$$ and decoder $$D$$. $$E$$ is used to convert a frame into a set of $$K$$ tokens $$(z^1, z^2, ..., z^K)$$, whereas $$D$$ is used to reconstruct the original image from the tokens. Why is this required? Because we are going to use a transformer as the actual "engine", and it only works at the level of tokens. Notice that we could treat each individual pixel as a single token, but as mentioned in the paper, the attention mechanism grows quadratically with the sequence length so this is unscalable.  

- A **transformer** $$G$$ to predict the next state of the environment. It receives sequences of consecutive frame/action tokens $$(z_0^1,...,z_0^K,a_0,...,z_t^1, ...,z_t^{K})$$

- A **policy** $$\pi$$, that will be used to select the action given the previous states. Obtaining a good policy is the main objective of the paper, but we actually care about properly modeling the game. 

{% include figure.liquid loading="eager" path="assets/img/IRIS_diagram.jpg" class="img-fluid rounded z-depth-1" %} IRIS diagram. Source: [3] 

Once that world model is trained, we will feed the initial frame to the encoder to obtain the initial tokens $$(z1_0,...,zK_0)$$. Then, instead of sampling the action from the policy, we will retrieve it from the actual user, then use GPT to generate the tokens of the next state, and then decode them to obtain the next frame.  

That's cool but, how do we actually train?. Essentially, each training step consists of three different processes:

1. **Collect experience:** Use the current policy to play the actual game and gather experience.
2. **Update the world model:** Use the previous experience to train $$E$$, $$D$$ and $$G$$ to properly predict the next observation, as well as the rewards and episode end.
3. **Update the behavior:** Improve the policy and value functions in the world model.

{% include figure.liquid loading="eager" path="assets/img/IRIS_algorithm.png" class="img-fluid rounded z-depth-1" %} IRIS algorithm. Source: [3]

## Getting our hands dirty: AI-Generated Pong

Instead of having to figure out everything before coding, let's get our hands dirty by trying to get a minimal working implementation. My idea is to first take a simple game (such as Pong) and try training a world model with just a random policy. In other words, this means gathering data from games where the policy is just "move up/down/do nothing with 33% probability" and train the world model with that data. Then, we can think about actually including RL. 

1. Setup Pong
2. Implement VQ-VAE
3. Implement GPT
4. Gather random experience and train the world model
5. Visualize world model
6. Interact with world model

#### 1. Setting up Pong

We are going to use [Gymnasium](https://gymnasium.farama.org/index.html), a maintained fork of OpenAI's Gym RL library. This library is really convenient as it already has implemented all the common RL environments, including Pong and other Atari games. Setting up Pong is really easy:

```python
import gymnasium as gym
import ale_py

gym.register_envs(ale_py)  # optional, helpful for IDEs or pre-commit

env = gym.make("ALE/Pong-v5", render_mode="rgb_array")

# Reset the environment to start
observation, info = env.reset()

frames = [observation]
# Run a random action loop
for _ in range(1000):
    action = env.action_space.sample()  # Choose a random action
    observation, reward, done, truncated, info = env.step(action)  # Take a step
    frames.append(observation)
    if done or truncated:
        observation, info = env.reset()  # Reset the environment if done or truncated
env.close()  # Close the environment

import cv2
out = cv2.VideoWriter('pong.mp4', cv2.VideoWriter_fourcc(*'H264'), 30, (frames[0].shape[1], frames[0].shape[0]))
for frame in frames:
    out.write(cv2.cvtColor(frame, cv2.COLOR_RGB2BGR))
out.release()
```

The snippet above creates a Pong environment with `gym.make` and starts it with `env.reset()`. This function returns `observation`, which is a `(210x160, 3)` RGB array of the screen, and `info` about the environment. Then, for 1000 steps, it randomly selects an action and executes it inside of the game, obtaining the next `observation` of the environment, as well as the `reward` for taking the action, whether the agent reaches terminal state (`done`), and whether the execution has reached its limit (`truncated`).

The last part of the snippet is just used to save a video of the simulation:

{% include video.liquid path="assets/video/pong.mp4" class="img-fluid rounded z-depth-1" controls=false autoplay=true loop=true %} 

As you can see, our random strategy leaves a lot to be desired: it only returns the ball twice in 1000 steps, and ends up with a score of zero! This implies that the data collected from this random agent will leave out a lot of the game logic (e.g. the dynamics of the ball, the green score counter) that the world model will not be able to, well, model. 

In other words, we should expect that a world model trained from the random agent experience will properly model the movement of our player, and maybe the first collision of the ball, but the other mechanics will be undefined as it hasn't seen any data about them. 

For now, we are going to implement the actual world model, train it with the experience of the random agent, and test whether this is true or not. Then, we will actually implement a proper RL agent.

### === UNDER CONSTRUCTION ===

#### 2. Implement VQ-VAE

For the implementation, I think that I am going to use the one from [commaVQ](https://github.com/commaai/commavq/tree/master).

How does it work?

Hyperparameters from IRIS paper

Brief snippet about dimensions

### References

[1] <https://worldmodels.github.io/>

[2] <https://github.com/etched-ai/open-oasis/>

[3] <https://arxiv.org/pdf/2209.00588/>

