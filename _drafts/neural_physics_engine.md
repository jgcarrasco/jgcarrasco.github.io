---
layout: post
title: Simulating games with neural networks
date: 2025-01-13
description: this is what included image galleries could look like
tags: formatting images
categories: sample-posts
thumbnail: assets/img/9.jpg
images:
  lightbox2: true
  photoswipe: true
  spotlight: true
  venobox: true
---

# Simulating Games with Neural Networks

I recently found out about [Oasis](https://oasisaiminecraft.com/), an AI-generated Minecraft clone. You can actually play it right now from your browser, and I encourage you to do it! What you will see is entirely AI-generated: you select a world (which is just a screenshot of a scene) and then the following frames are entirely generated by a neural network.

Roughly, my guess is they gathered lots of gameplay data and trained a model to predict the next frame given the current frame and user input. Once the model is trained, it can be used as some sort of "game engine" by just feeding a screenshot of the game. Then, the neural network will start generating the next frames conditioned on our input. 

I find this idea fascinating: we are replacing all the game/code logic by a neural network that has been only trained on image data.

The idea of this blog post is to log my adventure into learning and (hopefully) building a similar AI-generated game engine. I want to make this public since the start so that I commit to it. However, expect this to be a little bit messy at first!

## World Models

If we want to build a similar AI-generated game, the first thing to do is to look into the literature. I found out that Oasis is powered by a world model [1], whose task is to predict the next state of the world given the previous state/s and action/s. You can find quite a lot of papers related to world models, as well as technical info about Oasis [2].

However, I think that it is important to not overcomplicate things when building something for the first time. In this specific case, it implies (i) avoiding models/techniques that require a huge amount of computing (e.g. training a ViT on lots of Minecraft gameplay) and (ii) avoiding super complicated techniques that provide marginal increases in performance. In other words, adding a complicated training scheme to improve performance by 2% may be essential when building an actual product, but if we want to learn, we should get away with the simplest solution.

I think that IRIS [3] is a good candidate, as it is relatively simple, it works on small Atari games requiring small amounts of data and I think that it is also being used in production at comma.ai. 

Also note that most of the papers that talk about world models are related to Reinforcement Learning (RL). The main idea of all those papers is that RL agents are extremely sample inefficient, so it might be a good idea to learn a world model of the environment that can then be used to train the RL agent in its own "imagination". Most papers follow a scheme of (i) gathering observations from the environment (ii) training the world model (iii) training the RL agent with the world model. In our case, we are only interested in the second step, while the RL agent is just used to gather data from the environment (instead of us having to play for hours to gather data). In other words, we actually don't care that the RL agent performs well, we just want to have a decent world model.

## IRIS

Let's look at the diagram below. We have the following components:

- A **discrete autoencoder** composed by the encoder $E$ and decoder $D$. $E$ is used to convert a frame into a set of $K$ tokens $(z1, z2, ..., zK)$, whereas $D$ is used to reconstruct the original image from the tokens. Why is this required? Because we are going to use a transformer as the actual "engine", and it only works at the level of tokens. Notice that we could treat each individual pixel as a single token, but as mentioned in the paper, the attention mechanism grows quadratically with the sequence length so this is unscalable.  

- A **transformer** $G$ to predict the next state of the environment. It receives sequences of consecutive frame/action tokens $(z1_0,...,zK_0,a_0,...,z1_t, ...,zK_{t})$

- A **policy** $\pi$, that will be used to select the action given the previous states. Obtaining a good policy is the main objective of the paper, but we actually care about properly modeling the game. 

![IRIS diagram. Source: [3]](../images/blog/IRIS_diagram.png)

Once that world model is trained, we will feed the initial frame to the encoder to obtain the initial tokens $(z1_0,...,zK_0)$. Then, instead of sampling the action from the policy, we will retrieve it from the actual user, then use GPT to generate the tokens of the next state, and then decode them to obtain the next frame.  

That's cool but, how do we actually train?. Essentially, each training step consists of three different processes:

1. **Collect experience:** Use the current policy to play the actual game and gather experience.
2. **Update the world model:** Use the previous experience to train E, D and G to properly predict the next observation, as well as the rewards and episode end.
3. **Update the behavior:** Improve the policy and value functions in the world model.

![IRIS algorithm. Source: [3]](../images/blog/IRIS_algorithm.png)

## Getting our hands dirty: AI-Generated Pong

Instead of having to figure out everything before coding, let's get our hands dirty by trying to get a minimal working implementation. My idea is to first take a simple game (such as Pong) and try training a world model with just a random policy. In other words, this means gathering data from games where the policy is just "move up/down/do nothing with 33\% probability" and train the world model with that data. Then, we can think about actually including RL.   

0. Train a simple RL agent to collect experience in step 4. (Note that the aim of the paper is to train the agent in the imagination. But we are interested in collecting decent data. A random policy might not work because it will be very hard to return the ball, therefore the will not be able to feed data from a lot of situations to the world model.)
1. Setup Pong
2. Implement VQ-VAE
3. Implement GPT
4. Gather random experience and train it
5. Visualize world model
6. Interact with world model


### References

[1] <https://worldmodels.github.io/>

[2] <https://github.com/etched-ai/open-oasis/>

[3] <https://arxiv.org/pdf/2209.00588/>

### === UNDER CONSTRUCTION ===